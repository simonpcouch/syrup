[{"path":"https://simonpcouch.github.io/syrup/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Posit Software, PBC Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://simonpcouch.github.io/syrup/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon Couch. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://simonpcouch.github.io/syrup/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Couch S (2024). syrup: Measure Memory Usage Parallel R Code. R package version 0.0.0.9000, https://simonpcouch.github.io/syrup/, https://github.com/simonpcouch/syrup.","code":"@Manual{,   title = {syrup: Measure Memory Usage for Parallel R Code},   author = {Simon Couch},   year = {2024},   note = {R package version 0.0.0.9000, https://simonpcouch.github.io/syrup/},   url = {https://github.com/simonpcouch/syrup}, }"},{"path":"https://simonpcouch.github.io/syrup/index.html","id":"syrup","dir":"","previous_headings":"","what":"Measure Memory Usage for Parallel R Code","title":"Measure Memory Usage for Parallel R Code","text":"goal syrup coarsely measure memory usage R code run parallel regularly taking snapshots calls system command ps. package name homage syrupy (SYstem Resource Usage Profile …um, Yeah), Python tool jeetsukumaran/Syrupy. package highly experimental results interpreted caution.","code":""},{"path":"https://simonpcouch.github.io/syrup/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Measure Memory Usage for Parallel R Code","text":"can install development version syrup like :","code":"pak::pak(\"simonpcouch/syrup\")"},{"path":"https://simonpcouch.github.io/syrup/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Measure Memory Usage for Parallel R Code","text":"’ll demo using package (admittedly dependency-heavy) example tuning regularized linear model resamples. First, loading needed packages: Using future define parallelism strategy, ’ll set plan(multicore), indicating ’d like use forking 5 workers. default, future disables forking RStudio; know , context building README, usage forking safe, ’ll temporarily override default parallelly.fork.enable. Now, simulating data: main function syrup package, syrup(), takes expression argument: function works : Setting another R process sesh queries system information regular interval, Evaluating supplied expression, Reading queried system information back main process sesh, Closing sesh, Returning queried system information. output tibble: tibble, id defines specific time point process usage snapshotted, remaining columns show output ps::ps(). Notably, pid process ID, ppid process ID parent process, rss resident set size (measure memory usage). can plot get better sense memory usage processes changes time.  first, parent process non-NA rss, tidymodels hasn’t sent data workers yet. , 5 workers receives data tidymodels begins fitting models. Eventually, workers returns results parent process, rss NA. parent process wraps computations completing evaluation expression, point syrup() returns. Note memory weird; plot, total memory allotted parent session five workers ID simply sum rss values, memory shared among .","code":"library(syrup) library(future) library(tidymodels) library(rlang) local_options(parallelly.fork.enable = TRUE) plan(multicore, workers = 5) set.seed(1) dat <- sim_regression(1000000)  dat #> # A tibble: 1,000,000 × 21 #>    outcome predictor_01 predictor_02 predictor_03 predictor_04 predictor_05 #>      <dbl>        <dbl>        <dbl>        <dbl>        <dbl>        <dbl> #>  1    3.63       -1.88        0.872       -0.799       -0.0379       2.68   #>  2   41.6         0.551      -2.47         2.37         3.90         5.18   #>  3   -6.99       -2.51       -3.15         2.61         2.13         3.08   #>  4   33.2         4.79        1.86        -2.37         4.27        -3.59   #>  5   34.3         0.989      -0.315        3.08         2.56        -5.91   #>  6   26.7        -2.46       -0.459        1.75        -5.24         5.04   #>  7   21.4         1.46       -0.674       -0.894       -3.91        -3.38   #>  8   21.7         2.21        1.28        -1.05        -0.561        2.99   #>  9   -8.84        1.73        0.0725       0.0976       5.40         4.30   #> 10   24.5        -0.916      -0.223       -0.561       -4.12         0.0508 #> # ℹ 999,990 more rows #> # ℹ 15 more variables: predictor_06 <dbl>, predictor_07 <dbl>, #> #   predictor_08 <dbl>, predictor_09 <dbl>, predictor_10 <dbl>, #> #   predictor_11 <dbl>, predictor_12 <dbl>, predictor_13 <dbl>, #> #   predictor_14 <dbl>, predictor_15 <dbl>, predictor_16 <dbl>, #> #   predictor_17 <dbl>, predictor_18 <dbl>, predictor_19 <dbl>, #> #   predictor_20 <dbl> res_mem <- syrup({   res <-     tune_grid(       linear_reg(engine = \"glmnet\", penalty = tune()),       outcome ~ .,       vfold_cv(dat)     ) }) res_mem #> # A tibble: 60 × 6 #>       id   pid  ppid name                 rss       vms #>    <dbl> <int> <int> <chr>          <bch:byt> <bch:byt> #>  1     1 58494 58354 rsession-arm64  542.34MB     393GB #>  2     1 59643 58494 R                 1.08GB     393GB #>  3     2 58494 58354 rsession-arm64  542.34MB     393GB #>  4     2 59643 58494 R                 1.23GB     393GB #>  5     2 59660 59643 R               526.48MB     393GB #>  6     2 59661 59643 R               489.86MB     393GB #>  7     2 59662 59643 R                403.3MB     393GB #>  8     2 59663 59643 R               327.42MB     393GB #>  9     2 59664 59643 R               179.06MB     393GB #> 10     3 58494 58354 rsession-arm64  542.34MB     393GB #> # ℹ 50 more rows worker_ppid <- names(sort(-table(res_mem$ppid)))[1]  res_mem %>%   filter(ppid == worker_ppid | pid == worker_ppid) %>%   ggplot() +   aes(x = id, y = rss, group = pid) +   geom_line() +   scale_x_continuous(breaks = 1:max(res_mem$id))"},{"path":"https://simonpcouch.github.io/syrup/index.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Measure Memory Usage for Parallel R Code","text":"’s nothing specific package necessitates expression provided syrup() run parallel. Said another way, syrup work just fine “normal,” sequentially-run R code. said, many better, fine-grained tools job case sequential R code, Rprofmem(), profmem package, bench package, packages R-prof GitHub organization. Results syrup provide enough detail coarsest analyses memory usage, provide entry “profiling” memory usage R code runs parallel.","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup-package.html","id":null,"dir":"Reference","previous_headings":"","what":"syrup: Measure Memory Usage for Parallel R Code — syrup-package","title":"syrup: Measure Memory Usage for Parallel R Code — syrup-package","text":"Coarsely measures memory usage R code run parallel regularly taking snapshots calls system command ps.","code":""},{"path":[]},{"path":"https://simonpcouch.github.io/syrup/reference/syrup-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"syrup: Measure Memory Usage for Parallel R Code — syrup-package","text":"Maintainer: Simon Couch simon.couch@posit.co (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":null,"dir":"Reference","previous_headings":"","what":"Memory Usage Information for Parallel R Code — syrup","title":"Memory Usage Information for Parallel R Code — syrup","text":"function wrapper around system command ps can used benchmark (peak) memory usage parallel R code. taking snapshots memory usage R processes regular interval, function dynamically builds  profile usage system resources.","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Memory Usage Information for Parallel R Code — syrup","text":"","code":"syrup(expr, interval = 0.5, peak = FALSE, env = caller_env())"},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Memory Usage Information for Parallel R Code — syrup","text":"expr expression. interval interval take snapshots memory usage. practice, overhead top intervals. peak Whether return rows \"peak\" memory usage. Interpreted id maximum rss sum. Defaults FALSE, may helpful set peak = TRUE potentially long-running processes tibble grow large. env environment evaluate expr .","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Memory Usage Information for Parallel R Code — syrup","text":"tibble column id number columns ps::ps() output describing memory usage. Notably, process ID pid, parent process ID ppid, resident set size rss (measure memory usage).","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Memory Usage Information for Parallel R Code — syrup","text":"nothing specific function necessitates provided expression run parallel. Said another way, syrup() work just fine \"normal,\" sequentially-run R code (examples). said, many better, fine-grained tools job case sequential R code, Rprofmem(), profmem package, bench package, packages R-prof GitHub organization. Loosely, function works : Setting another R process (call sesh) queries system information using ps::ps() regular interval, Evaluating supplied expression, Reading queried system information back main process sesh, Closing sesh, Returning queried system information. Note information R process sesh filtered results automatically.","code":""},{"path":"https://simonpcouch.github.io/syrup/reference/syrup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Memory Usage Information for Parallel R Code — syrup","text":"","code":"# pass any expression to syrup. first, sequentially: res_syrup <- syrup({res_output <- Sys.sleep(1)})  res_syrup #> # A tibble: 3 × 6 #>      id   pid  ppid name        rss       vms #>   <dbl> <int> <int> <chr> <bch:byt> <bch:byt> #> 1     1  5830  1631 R         259MB     918MB #> 2     2  5830  1631 R         259MB     918MB #> 3     3  5830  1631 R         259MB     918MB  # to snapshot memory information more (or less) often, set `interval` syrup(Sys.sleep(1), interval = .01) #> # A tibble: 32 × 6 #>       id   pid  ppid name        rss       vms #>    <dbl> <int> <int> <chr> <bch:byt> <bch:byt> #>  1     1  5830  1631 R         262MB     921MB #>  2     2  5830  1631 R         262MB     921MB #>  3     3  5830  1631 R         262MB     921MB #>  4     4  5830  1631 R         262MB     921MB #>  5     5  5830  1631 R         262MB     921MB #>  6     6  5830  1631 R         262MB     921MB #>  7     7  5830  1631 R         262MB     921MB #>  8     8  5830  1631 R         262MB     921MB #>  9     9  5830  1631 R         262MB     921MB #> 10    10  5830  1631 R         262MB     921MB #> # ℹ 22 more rows  # use `peak = TRUE` to return only the snapshot with # the highest memory usage (as `sum(rss)`) syrup(Sys.sleep(1), interval = .01, peak = TRUE) #> # A tibble: 1 × 6 #>      id   pid  ppid name        rss       vms #>   <dbl> <int> <int> <chr> <bch:byt> <bch:byt> #> 1     1  5830  1631 R         262MB     921MB  # results from syrup are more---or maybe only---useful when # computations are evaluated in parallel. see package README # for an example."}]
